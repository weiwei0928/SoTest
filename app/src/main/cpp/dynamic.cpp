#include <jni.h>
#include <string>

/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_ww_sotest_Dynamic */

#ifndef _Included_com_ww_sotest_Dynamic
#define _Included_com_ww_sotest_Dynamic
#ifdef __cplusplus
extern "C" {
#endif

/** add()方法参数解释:
* 参数 JNIEnv *jniEnv : JNI环境       (固定写法:  JNIEnv *变量名)
* 参数 jobject jobject1 java中的对象   (固定写法: jobject 变量名 )
* 参数 jint1,jint2 : 对应的是java中的dynamic_add()的参数v1,v2
*/

jint add(JNIEnv *jniEnv, jclass jobject1, jint jint1, jint jint2) {
    return jint1 + jint2;
}


/**
 * 方法签名的组成规则为：(参数类型标识1参数类型标识2…参数类型标识n)返回值类型标识
 * 类型标识	Java数据类型
 * Z	        boolean
 * B	        byte
 * C	        char
 * S	        short
 * I	        int
 * J	        long
 * F	        float
 * D	        double
 * L包名/类名;	各种引用类型
 * V	        void
 *
 * cd到编译出来的class目录下  执行 javap -s 全类名  也可以查看签名  举例： cd tmp/kotlin-classes   javap -s com.ww.sotest.MainActivity
 *
 * */
static JNINativeMethod nativeMethod[] = {
        {"add", "(II)I", (void *) add},
};


JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) {
    //初始化JNI环境的指针变量
    JNIEnv *env = NULL;

    // 在JVM中找到可以正常使用的JNI版本(在JVM中使用的版本)
    if ((*vm).GetEnv((void **) &env, JNI_VERSION_1_2) != JNI_OK) {
        return JNI_ERR;
    }

    // 通过JNI层提供的FindClass方法找到JAVA层中声明了native方法的类(可以理解JNI层调用JAVA的类)
    jclass clazz = (*env).FindClass("com/ww/sotest/Dynamic");

    // JNI层的注册方法(用来本地注册JNINativeMethod数组里的映射关系,绑定+注册->才可以起到JAVA层调用JNI层本地方法的效果)
    // 注册成功会返回1,否则返回-1
    int result = (*env).RegisterNatives(clazz, nativeMethod,
                                        sizeof(nativeMethod) / sizeof(nativeMethod[0]));
    /**JNI_OnLoad()方法参数:
    * JavaVM *vm : java虚拟机   (固定格式: JavaVM *变量名)
    * void *reserved : 整体都是固定格式
    */

    /**注意:
    * 	1.JNI_VERSION_1_2可以在jni的头文件里(jni.h)找到.
    *		2.FindClass()方法中的参数 "com/confused/testjni/Dynamic"就是你的JAVA类的路径
    *		3.RegisterNatives方法的参数:(JNI环境,JNI层调用的JAVA类,绑定映射关系的数组,数组的大小(数组里有几个{}映射关系))
    */

    if (result < 0) {
        return JNI_ERR;
    }
    // 注册完成后一定要返回JNI的版本号,目的是告诉JVM用这个版本就对了(与上边GetEnv()里的版本相对应)
    return JNI_VERSION_1_2;

}


#ifdef __cplusplus
}
#endif
#endif

